---
title: Server-side Processing in R
---

---

We have been using client-side processing in all the above examples, i.e., searching, pagination, and ordering are done using JavaScript in the web browser. When the size of the data is huge, it may be more efficient to process the data on the server. DataTables supports retrieving data from a server by sending Ajax requests, a.k.a the ["server-side processing"](http://datatables.net/examples/data_sources/server_side.html).

To enable server-side processing, we need to use the option `serverSide`, e.g.,

```r
datatable(..., options = list(serverSide = TRUE))
```

In fact, `datatable()` has an argument `server` that can be set to `TRUE`, which will automatically set `serverSide = TRUE` in `options`.

# A JSONP Example

Now let's try the [JSONP data source example](http://datatables.net/examples/server_side/jsonp.html) on the DataTables website. It is fairly simple to reproduce that example here using the `datatable()` function with an option `ajax` that specifies the data URL:

```{r}
employee = data.frame(
  `First name` = character(), `Last name` = character(), Position = character(),
  Office = character(), `Start date` = character(), Salary = numeric(),
  check.names = FALSE
)
datatable(employee, server = TRUE, options = list(
  ajax = list(
    url = 'http://datatables.net/examples/server_side/scripts/jsonp.php',
    dataType = 'jsonp'
  )
))
```

# A Shiny Example

If you have used **DataTables** in **shiny** before, you might know that **shiny** uses the server-side processing model for **DataTables**, which basically means the data is processed through R, and R will return the JSON data to the client. The key pieces that makes this work are two functions: `session$registerDataObj()`, and `shiny:::dataTablesJSON()` (now moved to **DT** as `DT:::dataTablesJSON()`). The former registers a data object in the shiny session and returns a URL, which can be used as the server URL for `datatable()`; the latter was designed to process the data according to the Ajax request sent from **DataTables** and return JSON data. We can put these two pieces together and use them in a shiny app. There is an example in the **DT** package, which you can run by

```{r eval=FALSE}
shiny::runApp(system.file('examples', 'DT-shiny', package = 'DT'))
```

Below is the source code of the example app:

## ui.R

```{r include=FALSE}
DTShinyEx = function(file) {
  readLines(system.file('examples', 'DT-shiny', file, package = 'DT'))
}
```

```{r ui, code=DTShinyEx('ui.R'), eval=FALSE}
```

## server.R

```{r server, code=DTShinyEx('server.R'), eval=FALSE}
```

That is more or less how **DataTables** used to work internally in **shiny**. Now we have moved the server-side processing function `dataTablesJSON()` from shiny to **DT**, and provided a wrapper function `DT::dataTableAjax()` to make it easier for you register a data object in the shiny session that will return JSON when **DataTables** sends Ajax requests.

Alternatively, you can write a shiny app using a single script `app.R` that returns a `shinyApp()` object. For example, below is a function that returns a shiny app:

```{r code=DTShinyEx('../ajax-shiny.R')[2:18], eval=FALSE}
```

Then you can call the function to create the app at the end of `app.R`, e.g.

```{r eval=FALSE}
DTApp(iris, filter = 'top')
```

You will be able to either call `shiny::runApp()` to run `app.R`, or simply paste the code in R to run the app.
