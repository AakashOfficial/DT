#' Helper functions for using DT in Shiny
#'
#' These two functions are like most \code{fooOutput()} and \code{renderFoo()}
#' functions in the \pkg{shiny} package. The former is used to create a
#' container for table, and the latter is used in the server logic to render the
#' table.
#' @inheritParams shiny::dataTableOutput
#' @param width the width of the table container
#' @param height the height of the table container
#' @export
#' @examples # !formatR
#' if (interactive()) {
#'   library(shiny)
#'   shinyApp(
#'     ui = fluidPage(fluidRow(column(12, DT::dataTableOutput('tbl')))),
#'     server = function(input, output) {
#'       output$tbl = DT::renderDataTable(DT::datatable(iris))
#'     }
#'   )
#' }
dataTableOutput = function(outputId, width = '100%', height = 'auto') {
  htmlwidgets::shinyWidgetOutput(
    outputId, 'datatables', width, height, package = 'DT'
  )
}

#' @export
#' @rdname dataTableOutput
#' @inheritParams shiny::renderDataTable
#' @param expr an expression to create a table widget
#' @param ... currently ignored, with a warning message
renderDataTable = function(expr, env = parent.frame(), quoted = FALSE, ...) {
  if (length(list(...))) warning(
    "Arguments in addition to 'expr', 'env', and 'quoted' are ignored. ",
    "If you came from shiny::renderDataTable(), you may want to pass ",
    "these arguments to DT::datatable() instead."
  )
  if (!quoted) expr = substitute(expr)
  htmlwidgets::shinyRenderWidget(expr, dataTableOutput, env, quoted = TRUE)
}

#' Append a column of checkboxes to the data for selecting rows
#'
#' Append a column of checkboxes with the CSS class \samp{DT checkboxRows} to
#' the data. The checkboxes can be used for selecting rows in Shiny. Each
#' checkbox has a data field \samp{data-row} that contains the index of the
#' current row. The HTML code for checkboxes are generated by
#' \code{checkboxRows()}.
#'
#' For a table output with id \code{foo} in Shiny, the indices of the selected
#' rows are stored in \code{input$foo_selected}.
#' @param data the data to be displayed as the table
#' @param after add the checkboxes after the last column (\code{TRUE}) or before
#'   the first column (\code{FALSE}) of the table
#' @param checked which checkboxes are checked initially (a logical or numeric
#'   vector)
#' @references See \url{http://rstudio.github.io/DT/shiny.html} for examples.
#' @examples library(DT)
#' datatable(appendCheckboxes(iris), escape = -7)
#' @export
appendCheckboxes = function(data, after = TRUE, checked = FALSE) {
  check = checkboxRows(data, checked)
  if (after) cbind(data, ' ' = check) else cbind(' ' = check, data)
}

#' @rdname appendCheckboxes
#' @export
checkboxRows = function(data, checked = FALSE) {
  n = nrow(data)
  s = character(n)
  # we could have generated the checkboxes from tags$input() but it is much
  # slower than the simple sprintf() here; on the other hand, there is no need
  # to escape numbers seq_len(n) since they do not contain special HTML chars
  s[checked] = 'checked '
  sprintf(
    '<input data-row="%s" type="checkbox" class="DT checkboxRows" %s/>',
    seq_len(n), s
  )
}

shinyFun = function(name) getFromNamespace(name, 'shiny')

#' @export
dataTableAjax = function(session, data, rownames) {

  # abuse tempfile() to obtain a random id unique to this R session
  id = basename(tempfile(''))

  # deal with row names: rownames = TRUE or missing, use rownames(data)
  rn = if (missing(rownames) || isTRUE(rownames)) base::rownames(data) else {
    if (is.character(rownames)) rownames  # use custom row names
  }
  if (is.data.frame(data)) data = as.data.frame(data)  # think dplyr
  if (length(rn)) data = cbind(' ' = rn, data)

  session$registerDataObj(id, data, dataTablesJSON)

}

# convert a data frame to JSON as required by DataTables request
dataTablesJSON = function(data, req) {
  n = nrow(data)
  # DataTables requests were sent via POST
  URLdecode = shinyFun('URLdecode')
  params = URLdecode(rawToChar(req$rook.input$read()))
  q = parseQueryString(params, nested = TRUE)
  ci = q$search[['caseInsensitive']] == 'true'

  # global searching
  i = seq_len(n)
  if (q$search[['value']] != '') {
    i0 = apply(data, 2, function(x) {
      grep2(q$search[['value']], as.character(x),
            fixed = q$search[['regex']] == 'false', ignore.case = ci)
    })
    i = intersect(i, unique(unlist(i0)))
  }

  # search by columns
  if (length(i)) for (j in names(q$columns)) {
    col = q$columns[[j]]
    # if the j-th column is not searchable or the search string is "", skip it
    if (col[['searchable']] != 'true') next
    if ((k <- col[['search']][['value']]) == '') next
    j = as.integer(j)
    dj = data[, j + 1]
    r = commaToRange(k)
    ij = if (length(r) == 2 && (is.numeric(dj) || is.Date(dj))) {
      if (is.Date(dj)) {
        # r is milliseconds
        r = as.POSIXct(r / 1000, origin = '1970-01-01')
        if (inherits(dj, 'Date')) r = as.Date(r)
      }
      which(dj >= r[1] & dj <= r[2])
    } else {
      grep2(k, as.character(dj), fixed = col[['search']][['regex']] == 'false',
            ignore.case = ci)
    }
    i = intersect(ij, i)
    if (length(i) == 0) break
  }
  if (length(i) != n) data = data[i, , drop = FALSE]

  # sorting
  oList = list()
  for (ord in q$order) {
    k = ord[['column']]  # which column to sort
    d = ord[['dir']]     # direction asc/desc
    if (q$columns[[k]][['orderable']] != 'true') next
    col = data[, as.integer(k) + 1]
    oList[[length(oList) + 1]] = (if (d == 'asc') identity else `-`)(
      if (is.numeric(col)) col else xtfrm(col)
    )
  }
  if (length(oList)) {
    i = do.call(order, oList)
    data = data[i, , drop = FALSE]
  }
  # paging
  if (q$length != '-1') {
    i = seq(as.integer(q$start) + 1L, length.out = as.integer(q$length))
    i = i[i <= nrow(data)]
    fdata = data[i, , drop = FALSE]  # filtered data
  } else fdata = data

  fdata = unname(as.matrix(fdata))
  if (is.character(fdata) && q$escape != 'false') {
    if (q$escape == 'true') fdata = htmlEscape(fdata) else {
      k = as.integer(strsplit(q$escape, ',')[[1]])
      # use seq_len() in case escape = negative indices, e.g. c(-1, -5)
      for (j in seq_len(ncol(fdata))[k]) fdata[, j] = htmlEscape(fdata[, j])
    }
  }

  toJSON = shinyFun('toJSON')
  res = toJSON(list(
    draw = as.integer(q$draw),
    recordsTotal = n,
    recordsFiltered = nrow(data),
    data = fdata
  ))
  httpResponse = shinyFun('httpResponse')
  # TODO: enc2utf8() may not be necessary if we use jsonlite
  httpResponse(200, 'application/json', enc2utf8(res))
}

# when both ignore.case and fixed are TRUE, we use grep(ignore.case = FALSE,
# fixed = TRUE) to do lower-case matching of pattern on x
grep2 = function(pattern, x, ignore.case = FALSE, fixed = FALSE, ...) {
  if (fixed && ignore.case) {
    pattern = tolower(pattern)
    x = tolower(x)
    ignore.case = FALSE
  }
  # when the user types in the search box, the regular expression may not be
  # complete before it is sent to the server, in which case we do not search
  if (!fixed && inherits(try(grep(pattern, ''), silent = TRUE), 'try-error'))
    return(seq_along(x))
  grep(pattern, x, ignore.case = ignore.case, fixed = fixed, ...)
}

# convert a string of the form "lower,upper" to c(lower, upper)
commaToRange = function(string) {
  if (!grepl(',', string)) return()
  r = strsplit(string, ',')[[1]]
  if (length(r) > 2) return()
  if (length(r) == 1) r = c(r, '')  # lower,
  r = as.numeric(r)
  if (is.na(r[1])) r[1] = -Inf
  if (is.na(r[2])) r[2] = Inf
  r
}
